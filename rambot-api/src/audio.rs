use crate::SampleDuration;

use std::error::Error;
use std::fmt::{self, Display, Formatter};
use std::io;
use std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Sub, SubAssign};

/// A single stereo audio sample in 32-bit float PCM format. In memory, a
/// a sample is laid out as the left channel (4 bytes) followed by the right
/// channel (4 bytes) for a total of 8 bytes.
#[derive(Clone, Copy, Debug, PartialEq)]
#[repr(C)]
pub struct Sample {

    /// The current amplitude on the left channel. Usually on a scale from -1
    /// to 1.
    pub left: f32,

    /// The current amplitude on the right channel. Usually on a scale from -1
    /// to 1.
    pub right: f32
}

impl Sample {

    /// A sample which is zero on both channels.
    pub const ZERO: Sample = Sample {
        left: 0.0,
        right: 0.0
    };
}

impl AddAssign for Sample {
    fn add_assign(&mut self, rhs: Sample) {
        self.left += rhs.left;
        self.right += rhs.right;
    }
}

impl AddAssign<&Sample> for Sample {
    fn add_assign(&mut self, rhs: &Sample) {
        self.left += rhs.left;
        self.right += rhs.right;
    }
}

impl Add for Sample {
    type Output = Sample;

    fn add(mut self, rhs: Sample) -> Sample {
        self += rhs;
        self
    }
}

impl Add<&Sample> for Sample {
    type Output = Sample;

    fn add(mut self, rhs: &Sample) -> Sample {
        self += rhs;
        self
    }
}

impl Add for &Sample {
    type Output = Sample;

    fn add(self, rhs: &Sample) -> Sample {
        *self + rhs
    }
}

impl SubAssign for Sample {
    fn sub_assign(&mut self, rhs: Sample) {
        self.left -= rhs.left;
        self.right -= rhs.right;
    }
}

impl SubAssign<&Sample> for Sample {
    fn sub_assign(&mut self, rhs: &Sample) {
        self.left -= rhs.left;
        self.right -= rhs.right;
    }
}

impl Sub for Sample {
    type Output = Sample;

    fn sub(mut self, rhs: Sample) -> Sample {
        self -= rhs;
        self
    }
}

impl Sub<&Sample> for Sample {
    type Output = Sample;

    fn sub(mut self, rhs: &Sample) -> Sample {
        self -= rhs;
        self
    }
}

impl Sub for &Sample {
    type Output = Sample;

    fn sub(self, rhs: &Sample) -> Sample {
        *self - rhs
    }
}

impl MulAssign<f32> for Sample {
    fn mul_assign(&mut self, rhs: f32) {
        self.left *= rhs;
        self.right *= rhs;
    }
}

impl Mul<f32> for Sample {
    type Output = Sample;

    fn mul(mut self, rhs: f32) -> Sample {
        self *= rhs;
        self
    }
}

impl Mul<f32> for &Sample {
    type Output = Sample;

    fn mul(self, rhs: f32) -> Sample {
        *self * rhs
    }
}

impl DivAssign<f32> for Sample {
    fn div_assign(&mut self, rhs: f32) {
        self.left /= rhs;
        self.right /= rhs;
    }
}

impl Div<f32> for Sample {
    type Output = Sample;

    fn div(mut self, rhs: f32) -> Sample {
        self /= rhs;
        self
    }
}

impl Div<f32> for &Sample {
    type Output = Sample;

    fn div(self, rhs: f32) -> Sample {
        *self / rhs
    }
}

/// Contains meta-information about a track, such as the title and artist. This
/// has to be generated by plugins and provided to the bot in
/// [AudioSource::metadata]. The bot can then report it to the user. To
/// construct an instance, use the [AudioMetadataBuilder].
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct AudioMetadata {
    title: Option<String>,
    artist: Option<String>,
    album: Option<String>,
    year: Option<i32>
}

impl AudioMetadata {

    /// Gets the title of the track, if it could be determined.
    pub fn title(&self) -> Option<&str> {
        self.title.as_deref()
    }

    /// Gets the name of the artist of the track, if it could be determined.
    pub fn artist(&self) -> Option<&str> {
        self.artist.as_deref()
    }

    /// Gets the name of the album in which the track was released, if one
    /// exists and it could be determined.
    pub fn album(&self) -> Option<&str> {
        self.album.as_deref()
    }

    /// Gets the (Gregorian) year in which the track was released, if it could
    /// be determined.
    pub fn year(&self) -> Option<i32> {
        self.year
    }
}

/// A builder for [AudioMetadata] instances. Construct a new builder with
/// [AudioMetadataBuilder::new] and then call setters (`with_*`) to specify all
/// information that you can obtain. Values which are not set will be left
/// `None`. See below for an example.
///
/// ```
/// use rambot_api::AudioMetadataBuilder;
///
/// let metadata = AudioMetadataBuilder::new()
///     .with_title("hello")
///     .with_artist("world")
///     .with_year(2022)
///     .build();
///
/// assert_eq!(Some("hello"), metadata.title());
/// assert_eq!(Some("world"), metadata.artist());
/// assert_eq!(None, metadata.album());
/// assert_eq!(Some(2022), metadata.year());
/// ```
#[derive(Clone, Debug)]
pub struct AudioMetadataBuilder {
    audio_metadata: AudioMetadata
}

impl AudioMetadataBuilder {

    /// Creates a new audio metadata builder in which no values of the metadata
    /// are set.
    pub fn new() -> AudioMetadataBuilder {
        AudioMetadataBuilder {
            audio_metadata: AudioMetadata {
                title: None,
                artist: None,
                album: None,
                year: None
            }
        }
    }

    /// Specifies the title of the track. That is, the value provided here will
    /// be returned in [AudioMetadata::title].
    ///
    /// # Arguments
    ///
    /// * `title`: The title of the track.
    ///
    /// # Returns
    ///
    /// This builder for chaining.
    pub fn with_title<S>(mut self, title: S) -> AudioMetadataBuilder
    where
        S: Into<String>
    {
        self.audio_metadata.title = Some(title.into());
        self
    }

    /// Specifies the name of the artist of the track. That is, the value
    /// provided here will be returned in [AudioMetadata::artist].
    ///
    /// # Arguments
    ///
    /// * `artist`: The name of the artist of the track.
    ///
    /// # Returns
    ///
    /// This builder for chaining.
    pub fn with_artist<S>(mut self, artist: S) -> AudioMetadataBuilder
    where
        S: Into<String>
    {
        self.audio_metadata.artist = Some(artist.into());
        self
    }

    /// Specifies the name of the album in which the track was released. That
    /// is, the value provided here will be returned in [AudioMetadata::album].
    ///
    /// # Arguments
    ///
    /// * `album`: The name of the album in which the track was released.
    ///
    /// # Returns
    ///
    /// This builder for chaining.
    pub fn with_album<S>(mut self, album: S) -> AudioMetadataBuilder
    where
        S: Into<String>
    {
        self.audio_metadata.album = Some(album.into());
        self
    }

    /// Specifies the (Gregorian) year in which the track was released. That
    /// is, the value provided here will be returned in [AudioMetadata::album].
    ///
    /// # Arguments
    ///
    /// * `year`: The (Gregorian) year in which the track was released.
    ///
    /// # Returns
    ///
    /// This builder for chaining.
    pub fn with_year(mut self, year: i32) -> AudioMetadataBuilder {
        self.audio_metadata.year = Some(year);
        self
    }

    /// Constructs the [AudioMetadata] instance from the information provided
    /// in the previous `with_*` calls.
    pub fn build(self) -> AudioMetadata {
        self.audio_metadata
    }
}

impl Default for AudioMetadataBuilder {
    fn default() -> AudioMetadataBuilder {
        AudioMetadataBuilder::new()
    }
}

/// An enumeration of the different errors that can occur when calling
/// [AudioSource::seek].
#[derive(Debug)]
pub enum SeekError {

    /// The audio source does not support seeking by the given duration. As an
    /// example, some audio sources may only support seeking forward (with
    /// positive durations) and raise this issue if a seek backward (with
    /// negative duration) is requested.
    UnsupportedDelta,

    /// During an IO-based seeking operation, an IO error occurred. The error
    /// which was raised is wrapped in this variant.
    IoError(io::Error)
}

impl From<io::Error> for SeekError {
    fn from(e: io::Error) -> SeekError {
        SeekError::IoError(e)
    }
}

impl Display for SeekError {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self {
            SeekError::UnsupportedDelta =>
                write!(f, "The plugin does not support seeking by the given \
                    amount."),
            SeekError::IoError(e) =>
                write!(f, "An IO error occurred while seeking: {}", e)
        }
    }
}

impl Error for SeekError { }

const SEEK_DEFAULT_IMPL_BUF_SIZE: usize = 1024;

/// A trait for types which can read audio data in the form of [Sample]s. The
/// interface is similar to that of the IO [Read](std::io::Read) trait.
/// 
/// Audio provided to the bot must be at 48 kHz, that is, 48000 samples
/// represent one second of audio. This trait itself provides no way of
/// checking that, so it is the plugin's responsibility to output audio of the
/// correct sampling rate. You can use the `plugin-commons` crate's
/// `adapt_sampling_rate` function to resample an audio source of any sampling
/// rate to the required 48 kHz.
pub trait AudioSource {

    /// Reads samples from this source into the given buffer. If the audio
    /// source offers any more data, at least one new sample must be written.
    /// Otherwise, it is assumed that the audio has finished. The buffer does
    /// not need to be filled completely even if there is more audio to come.
    /// The return value indicates how much data was read.
    ///
    /// # Arguments
    ///
    /// * `buf`: A [Sample] buffer to fill with data, starting from index 0.
    /// May or may not be filled with junk.
    ///
    /// # Returns
    ///
    /// The number of samples which were entered into the buffer. That is, this
    /// audio source generated samples from index 0 to one less than this
    /// number (inclusively).
    ///
    /// # Errors
    ///
    /// Any IO-[Error](io::Error) that occurs during reading.
    fn read(&mut self, buf: &mut [Sample]) -> Result<usize, io::Error>;

    /// Moves the reader's current position in the audio by the given amount.
    /// That is, subsequent calls to [AudioSource::read] will continue from the
    /// current possition plus the given delta. There is no guarantee that this
    /// operation is supported. If it is not, then an appropriate error is
    /// raised.
    ///
    /// By default, this is implemented as seeking forward by calling
    /// [AudioSource::read] multiple times, reading into a buffer that is
    /// discarded afterwards. This is disadvantageous in two ways: It limits
    /// seeking to the forward direction, and it is inefficient from a
    /// performance perspective. Hence, if you want to support seeking in an
    /// effective manner, you should override this method.
    ///
    /// # Arguments
    ///
    /// * `delta`: The [SampleDuration] by which the position is moved.
    /// Positive values mean seeking forward, negative values mean seeking
    /// backward.
    ///
    /// # Errors
    ///
    /// Any [SeekError] according to their respective documentations.
    fn seek(&mut self, delta: SampleDuration) -> Result<(), SeekError> {
        if delta == SampleDuration::ZERO {
            return Ok(());
        }

        if delta < SampleDuration::ZERO {
            return Err(SeekError::UnsupportedDelta);
        }

        let mut samples = delta.samples() as u64;
        let mut buf = [Sample::ZERO; SEEK_DEFAULT_IMPL_BUF_SIZE];

        while samples > 0 {
            let buf_size =
                samples.min(SEEK_DEFAULT_IMPL_BUF_SIZE as u64) as usize;
            let count = self.read(&mut buf[..buf_size])?;

            if count == 0 {
                return Ok(());
            }

            samples -= count as u64;
        }

        Ok(())
    }

    /// Indicates whether this audio source wraps around a child source. This
    /// must be `true` for any audio source constituting an effect, i.e. which
    /// was resolved by an [EffectResolver](crate::resolver::EffectResolver).
    /// For example, a low-pass filter wraps around the root audio source which
    /// is filtered.
    fn has_child(&self) -> bool;

    /// Removes the child from this audio source and returns it. If
    /// [AudioSource::has_child] returns `true`, this must return a valid audio
    /// source, otherwise it may panic.
    ///
    /// Unless this method is called outside the framework, it is guaranteed
    /// that the audio source is dropped immediately afterwards. It is
    /// therefore not necessary to keep it in a usable state.
    fn take_child(&mut self) -> Box<dyn AudioSource + Send + Sync>;

    /// Obtains [AudioMetadata] containing information about the track
    /// currently played by this audio source.
    fn metadata(&self) -> AudioMetadata;
}

// TODO check whether you can get rid of this implementation

impl AudioSource for Box<dyn AudioSource + Send + Sync> {
    fn read(&mut self, buf: &mut [Sample]) -> Result<usize, io::Error> {
        self.as_mut().read(buf)
    }

    fn seek(&mut self, delta: SampleDuration) -> Result<(), SeekError> {
        self.as_mut().seek(delta)
    }

    fn has_child(&self) -> bool {
        self.as_ref().has_child()
    }

    fn take_child(&mut self) -> Box<dyn AudioSource + Send + Sync> {
        self.as_mut().take_child()
    }

    fn metadata(&self) -> AudioMetadata {
        self.as_ref().metadata()
    }
}

/// A trait for types which can offer a list or enumeration of descriptors,
/// such as a playlist or loop functionality.
pub trait AudioSourceList {

    /// Gets the next descriptor in the list, or `None` if the list is
    /// finished. May return an IO-[Error](io::Error) if the operation fails.
    fn next(&mut self) -> Result<Option<String>, io::Error>;
}
